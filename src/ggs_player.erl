-module(ggs_player).
-export([start_link/1, notify/3, get_token/1, stop/2]).
-record(pl_state,
        {token,         % Player's token
         socket,        % Player's socket
         table}).      % Player's table

%% @doc This module handles communication between a player and GGS. This module is
%%responsible for: 
%% * The storage of the player socket, player token and a table token.
%% * Ability to fetch a player token.
%% * Forwarding messages from players to the game
%% * Remove a player from GGS

%% @doc Spawns a process representing the player in GGS. Takes the player socket as
%% an argument for storage and later usage. Creates a unique player token
%% identifying the player.
%% @spec start_link(Socket::socket()) -> {ok, Pid} | {error, Reason}
start_link(Socket) -> 
    % The socket is in 'active' mode, and that means we are pushed any data
    % that arrives on it, we do not need to recv() manually. Since the socket
    % was opened in our parent process, we need to change the owner of it to
    % us, otherwise these messages end up in our parent.
    erlang:port_connect(Socket, self()),
    {ok, Token} = ggs_coordinator:join_lobby(),
    TableStatus = ggs_coordinator:join_table(1337),
    case TableStatus of
        {ok, Table} ->
            notify(self(), self(), Token),
            loop(#pl_state{socket = Socket, token = Token, table = Table});
        {error, no_such_table} ->
            ggs_coordinator:create_table({force, 1337}),
            {ok, Table} = ggs_coordinator:join_table(1337),
            notify(self(), self(), Token),
            loop(#pl_state{socket = Socket, token = Token, table = Table})
    end.

%% @doc Handles incoming messages from the GGS and forwards them through the player
%% socket to the player.
%% @spec notify(Player::Pid(), From::Pid(), 
%%              {Command::String(), Message::string()}) -> ok
notify(Player, From, Message) ->
    Player ! {notify, From, Message}.

%% @doc Get the player token uniquely representing the player.
%% @spec get_token() -> string()
get_token(_Player) ->
    ggs_logger:not_implemented().

%% @doc Properly terminates the player process. The player token will be lost
%% together with the table token. It should also close the player socket and the 
%% process should return in the end.
%% @spec stop(Table::pid()) -> Reason::string()
stop(_Player,_Table) ->
    ggs_logger:not_implemented().

%% Internals

loop(#pl_state{token = _Token, socket = Socket, table = Table} = State) ->
    receive 
        {tcp, Socket, Data} -> % Just echo for now..
            io:format("Parsing via protocol module..~n"),
            Parsed = ggs_protocol:parse(Data),
            self() ! Parsed,
            loop(State);
        {notify, _From, Message} ->
            gen_tcp:send(Socket, Message),
            loop(State);
        % Below are messages generated by the parser
        {game_cmd,Cmd, _Headers, Data} ->
            ggs_table:notify(Table, self(), {game, Cmd, Data}),
            loop(State);
        {srv_cmd,"define", _Headers, Data} ->
            ggs_table:notify(Table, self(), {server, define, Data}),
            loop(State);
        {tcp_closed, _Socket} ->
            io:format("Client disconnected, but THIS IS NOT SUPPORTED YET!~n"),
            loop(State);
        Other ->
            io:format("Got UNKNOWN message: "),
            erlang:display(Other),
            io:format("~n")
    end.
